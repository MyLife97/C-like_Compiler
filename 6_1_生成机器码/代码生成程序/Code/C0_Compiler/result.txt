1	1	1	CONST_SYMBOL	const
2	1	7	INT_SYMBOL	int
3	1	11	IDENT	max_value_limit
4	1	27	BECOME	=
5	1	29	INT	100
6	1	32	COMMA	,
7	1	34	IDENT	min_value_limit
8	1	50	BECOME	=
9	1	52	SUB	-
10	1	53	INT	100
11	1	56	SEMICOLON	;
12	2	1	CONST_SYMBOL	const
13	2	7	CHAR_SYMBOL	char
14	2	12	IDENT	upper_c
15	2	20	BECOME	=
16	2	22	CHAR	C
17	2	25	SEMICOLON	;
18	3	1	CONST_SYMBOL	const
19	3	7	INT_SYMBOL	int
20	3	11	IDENT	const_void_index
21	4	1	BECOME	=
22	5	1	INT	5
23	6	1	SEMICOLON	;
24	7	1	CONST_SYMBOL	const
25	7	7	CHAR_SYMBOL	char
26	7	12	IDENT	lower_c
27	7	20	BECOME	=
28	7	22	CHAR	c
29	7	25	SEMICOLON	;
30	10	1	INT_SYMBOL	int
31	10	5	IDENT	error_number
32	10	17	SEMICOLON	;
33	11	1	INT_SYMBOL	int
34	11	5	IDENT	void_index
35	11	15	SEMICOLON	;
36	12	1	INT_SYMBOL	int
37	12	5	IDENT	i
38	12	6	SEMICOLON	;
39	13	1	INT_SYMBOL	int
40	13	5	IDENT	t1
41	13	7	COMMA	,
42	13	8	IDENT	t2
43	14	1	COMMA	,
44	15	1	IDENT	t3
45	16	1	SEMICOLON	;
46	17	1	INT_SYMBOL	int
47	17	5	IDENT	t
48	17	6	LEFT_BRACKET	[
49	17	7	INT	10
50	17	9	RIGHT_BRACKET	]
51	17	10	SEMICOLON	;
52	18	1	CHAR_SYMBOL	char
53	18	6	IDENT	label
54	18	11	COMMA	,
55	18	13	IDENT	label1
56	18	19	COMMA	,
57	18	21	IDENT	label2
58	18	27	SEMICOLON	;
59	20	1	INT_SYMBOL	int
60	20	5	IDENT	returnyear
61	20	15	LEFT_BRACE	{
62	21	5	RETURN_SYMBOL	return
63	21	12	LEFT_PAR	(
64	21	13	SUB	-
65	21	14	SUB	-
66	21	15	INT	2017
67	21	19	SUB	-
68	21	20	SUB	-
69	21	21	INT	1
70	21	22	RIGHT_PAR	)
71	21	23	SEMICOLON	;
72	22	1	RIGHT_BRACE	}
73	24	1	INT_SYMBOL	int
74	24	5	IDENT	add
75	24	8	LEFT_PAR	(
76	24	9	INT_SYMBOL	int
77	24	13	IDENT	x
78	24	14	COMMA	,
79	24	16	INT_SYMBOL	int
80	24	20	IDENT	y
81	24	21	RIGHT_PAR	)
82	24	22	LEFT_BRACE	{
83	25	5	RETURN_SYMBOL	return
84	25	12	LEFT_PAR	(
85	25	13	PLUS	+
86	25	15	IDENT	x
87	25	17	PLUS	+
88	25	19	IDENT	y
89	25	20	RIGHT_PAR	)
90	25	21	SEMICOLON	;
91	26	1	RIGHT_BRACE	}
92	28	1	VOID_SYMBOL	void
93	28	6	IDENT	error
94	28	11	LEFT_PAR	(
95	28	12	INT_SYMBOL	int
96	28	16	IDENT	err_typ
97	28	23	RIGHT_PAR	)
98	28	24	LEFT_BRACE	{
99	29	5	SWITCH_SYMBOL	switch
100	29	11	LEFT_PAR	(
101	29	12	IDENT	err_typ
102	29	19	RIGHT_PAR	)
103	29	20	LEFT_BRACE	{
104	30	9	CASE_SYMBOL	case
105	30	14	INT	1
106	30	15	COLON	:
107	30	16	LEFT_BRACE	{
108	31	13	PRINTF_SYMBOL	printf
109	31	19	LEFT_PAR	(
110	31	20	STRING	Max value limit.
111	31	38	RIGHT_PAR	)
112	31	39	SEMICOLON	;
113	32	9	RIGHT_BRACE	}
114	33	9	CASE_SYMBOL	case
115	33	14	INT	2
116	33	15	COLON	:
117	33	16	LEFT_BRACE	{
118	34	13	PRINTF_SYMBOL	printf
119	34	19	LEFT_PAR	(
120	34	20	STRING	Min value limit.
121	34	38	RIGHT_PAR	)
122	34	39	SEMICOLON	;
123	35	9	RIGHT_BRACE	}
124	36	9	DEFAULT_SYMBOL	default
125	36	16	COLON	:
126	36	17	LEFT_BRACE	{
127	37	13	SWITCH_SYMBOL	switch
128	37	19	LEFT_PAR	(
129	37	20	IDENT	err_typ
130	37	27	RIGHT_PAR	)
131	37	28	LEFT_BRACE	{
132	38	17	CASE_SYMBOL	case
133	38	22	INT	3
134	38	23	COLON	:
135	39	21	PRINTF_SYMBOL	printf
136	39	27	LEFT_PAR	(
137	39	28	STRING	Invalid Input.
138	39	44	RIGHT_PAR	)
139	39	45	SEMICOLON	;
140	40	17	DEFAULT_SYMBOL	default
141	40	24	COLON	:
142	41	21	PRINTF_SYMBOL	printf
143	41	27	LEFT_PAR	(
144	41	28	STRING	Error Type Not Define.
145	41	52	RIGHT_PAR	)
146	41	53	SEMICOLON	;
147	42	13	RIGHT_BRACE	}
148	43	9	RIGHT_BRACE	}
149	44	5	RIGHT_BRACE	}
150	45	5	IDENT	error_number
151	45	18	BECOME	=
152	45	20	IDENT	error_number
153	45	33	PLUS	+
154	45	35	INT	1
155	45	36	SEMICOLON	;
156	46	5	RETURN_SYMBOL	return
157	46	11	SEMICOLON	;
158	47	1	RIGHT_BRACE	}
159	49	1	INT_SYMBOL	int
160	49	5	IDENT	cumulative_sum
161	49	19	LEFT_PAR	(
162	49	20	INT_SYMBOL	int
163	49	24	IDENT	x
164	49	25	COMMA	,
165	49	27	INT_SYMBOL	int
166	49	31	IDENT	y
167	49	32	RIGHT_PAR	)
168	49	33	LEFT_BRACE	{
169	51	5	CONST_SYMBOL	const
170	51	11	INT_SYMBOL	int
171	51	15	IDENT	err_max_value_limit
172	51	35	BECOME	=
173	51	37	INT	1
174	51	38	SEMICOLON	;
175	52	5	CONST_SYMBOL	const
176	52	11	INT_SYMBOL	int
177	52	15	IDENT	err_min_value_limit
178	52	35	BECOME	=
179	52	37	INT	2
180	52	38	SEMICOLON	;
181	53	5	CONST_SYMBOL	const
182	53	11	INT_SYMBOL	int
183	53	15	IDENT	err_invalid_input
184	53	33	BECOME	=
185	53	35	INT	3
186	53	36	SEMICOLON	;
187	55	5	IF_SYMBOL	if
188	55	7	LEFT_PAR	(
189	55	8	IDENT	x
190	55	10	GTR	>
191	55	12	IDENT	y
192	55	13	RIGHT_PAR	)
193	56	9	IDENT	error
194	56	14	LEFT_PAR	(
195	56	15	IDENT	err_invalid_input
196	56	32	RIGHT_PAR	)
197	56	33	SEMICOLON	;
198	57	5	ELSE_SYMBOL	else
199	58	9	IF_SYMBOL	if
200	58	11	LEFT_PAR	(
201	58	12	IDENT	y
202	58	14	GTR	>
203	58	16	IDENT	max_value_limit
204	58	31	RIGHT_PAR	)
205	59	13	IDENT	error
206	59	18	LEFT_PAR	(
207	59	19	IDENT	err_max_value_limit
208	59	38	RIGHT_PAR	)
209	59	39	SEMICOLON	;
210	60	9	ELSE_SYMBOL	else
211	61	13	IF_SYMBOL	if
212	61	15	LEFT_PAR	(
213	61	16	IDENT	x
214	61	18	LSS	<
215	61	20	IDENT	min_value_limit
216	61	35	RIGHT_PAR	)
217	62	17	IDENT	error
218	62	22	LEFT_PAR	(
219	62	23	IDENT	err_min_value_limit
220	62	42	RIGHT_PAR	)
221	62	43	SEMICOLON	;
222	63	13	ELSE_SYMBOL	else
223	64	17	IF_SYMBOL	if
224	64	19	LEFT_PAR	(
225	64	20	IDENT	x
226	64	22	SUB	-
227	64	24	IDENT	y
228	64	25	RIGHT_PAR	)
229	65	21	RETURN_SYMBOL	return
230	65	28	LEFT_PAR	(
231	65	29	IDENT	add
232	65	32	LEFT_PAR	(
233	65	33	IDENT	x
234	65	34	COMMA	,
235	65	36	IDENT	cumulative_sum
236	65	50	LEFT_PAR	(
237	65	51	IDENT	x
238	65	53	PLUS	+
239	65	55	INT	1
240	65	56	COMMA	,
241	65	58	IDENT	y
242	65	59	RIGHT_PAR	)
243	65	60	RIGHT_PAR	)
244	65	61	RIGHT_PAR	)
245	65	62	SEMICOLON	;
246	66	17	ELSE_SYMBOL	else
247	67	21	RETURN_SYMBOL	return
248	67	28	LEFT_PAR	(
249	67	29	IDENT	x
250	67	30	RIGHT_PAR	)
251	67	31	SEMICOLON	;
252	68	1	RIGHT_BRACE	}
253	72	1	CHAR_SYMBOL	char
254	72	6	IDENT	returnc
255	72	13	LEFT_BRACE	{
256	73	5	IF_SYMBOL	if
257	73	7	LEFT_PAR	(
258	73	8	IDENT	void_index
259	73	19	LSS	<
260	73	21	IDENT	const_void_index
261	73	37	RIGHT_PAR	)
262	73	38	LEFT_BRACE	{
263	74	9	IDENT	void_index
264	74	20	BECOME	=
265	74	22	IDENT	void_index
266	74	33	PLUS	+
267	74	35	INT	1
268	74	36	SEMICOLON	;
269	75	9	RETURN_SYMBOL	return
270	75	16	LEFT_PAR	(
271	75	17	IDENT	returnc
272	75	24	RIGHT_PAR	)
273	75	25	SEMICOLON	;
274	76	5	RIGHT_BRACE	}
275	77	5	ELSE_SYMBOL	else
276	78	9	RETURN_SYMBOL	return
277	78	16	LEFT_PAR	(
278	78	17	CHAR	C
279	78	20	RIGHT_PAR	)
280	78	21	SEMICOLON	;
281	79	1	RIGHT_BRACE	}
282	81	1	CHAR_SYMBOL	char
283	81	6	IDENT	output
284	81	12	LEFT_PAR	(
285	81	13	CHAR_SYMBOL	char
286	81	18	IDENT	input
287	81	23	RIGHT_PAR	)
288	81	24	LEFT_BRACE	{
289	82	2	DO_SYMBOL	do
290	82	4	LEFT_BRACE	{
291	83	3	PRINTF_SYMBOL	printf
292	83	9	LEFT_PAR	(
293	83	10	STRING	Letter is 
294	83	22	COMMA	,
295	83	24	IDENT	input
296	83	29	RIGHT_PAR	)
297	83	30	SEMICOLON	;
298	84	3	RETURN_SYMBOL	return
299	84	10	LEFT_PAR	(
300	84	11	IDENT	input
301	84	16	RIGHT_PAR	)
302	84	17	SEMICOLON	;
303	85	2	RIGHT_BRACE	}
304	85	3	WHILE_SYMBOL	while
305	85	8	LEFT_PAR	(
306	85	9	INT	1
307	85	10	RIGHT_PAR	)
308	85	11	SEMICOLON	;
309	86	1	RIGHT_BRACE	}
310	88	1	INT_SYMBOL	int
311	88	5	IDENT	register_disaster
312	88	22	LEFT_PAR	(
313	88	23	INT_SYMBOL	int
314	88	27	IDENT	t1
315	88	29	COMMA	,
316	88	31	INT_SYMBOL	int
317	88	35	IDENT	t2
318	88	37	COMMA	,
319	88	39	INT_SYMBOL	int
320	88	43	IDENT	t3
321	88	45	COMMA	,
322	88	47	INT_SYMBOL	int
323	88	51	IDENT	t4
324	88	53	COMMA	,
325	88	55	INT_SYMBOL	int
326	88	59	IDENT	t5
327	88	61	COMMA	,
328	88	63	INT_SYMBOL	int
329	88	67	IDENT	t6
330	88	69	COMMA	,
331	88	71	INT_SYMBOL	int
332	88	75	IDENT	t7
333	88	77	COMMA	,
334	88	79	INT_SYMBOL	int
335	88	83	IDENT	t8
336	88	85	COMMA	,
337	88	87	INT_SYMBOL	int
338	88	91	IDENT	t9
339	88	93	COMMA	,
340	88	95	INT_SYMBOL	int
341	88	99	IDENT	t10
342	88	102	COMMA	,
343	88	104	INT_SYMBOL	int
344	88	108	IDENT	t11
345	88	112	COMMA	,
346	88	113	INT_SYMBOL	int
347	88	117	IDENT	t12
348	88	120	RIGHT_PAR	)
349	88	121	LEFT_BRACE	{
350	89	2	IDENT	t1
351	89	5	BECOME	=
352	89	7	INT	1
353	89	8	SEMICOLON	;
354	90	2	IDENT	t2
355	90	5	BECOME	=
356	90	7	INT	1
357	90	8	SEMICOLON	;
358	91	2	IDENT	t3
359	91	5	BECOME	=
360	91	7	INT	1
361	91	8	SEMICOLON	;
362	92	2	IDENT	t4
363	92	5	BECOME	=
364	92	7	INT	1
365	92	8	SEMICOLON	;
366	93	2	IDENT	t5
367	93	5	BECOME	=
368	93	7	INT	1
369	93	8	SEMICOLON	;
370	94	2	IDENT	t6
371	94	5	BECOME	=
372	94	7	INT	1
373	94	8	SEMICOLON	;
374	95	2	IDENT	t7
375	95	5	BECOME	=
376	95	7	INT	1
377	95	8	SEMICOLON	;
378	96	2	IDENT	t8
379	96	5	BECOME	=
380	96	7	INT	1
381	96	8	SEMICOLON	;
382	97	2	IDENT	t9
383	97	5	BECOME	=
384	97	7	INT	1
385	97	8	SEMICOLON	;
386	98	2	IDENT	t10
387	98	6	BECOME	=
388	98	8	INT	1
389	98	9	SEMICOLON	;
390	99	2	IDENT	t11
391	99	6	BECOME	=
392	99	8	INT	1
393	99	9	SEMICOLON	;
394	100	2	IDENT	t12
395	100	6	BECOME	=
396	100	8	INT	1
397	100	9	SEMICOLON	;
398	101	2	RETURN_SYMBOL	return
399	101	9	LEFT_PAR	(
400	101	10	IDENT	t1
401	101	13	PLUS	+
402	101	15	IDENT	t2
403	101	18	PLUS	+
404	101	20	IDENT	t3
405	101	23	PLUS	+
406	101	25	IDENT	t4
407	101	28	PLUS	+
408	101	30	IDENT	t5
409	101	33	PLUS	+
410	101	35	IDENT	t6
411	101	38	PLUS	+
412	101	40	IDENT	t7
413	101	43	PLUS	+
414	101	45	IDENT	t8
415	101	48	PLUS	+
416	101	50	IDENT	t9
417	101	53	PLUS	+
418	101	55	IDENT	t10
419	101	59	PLUS	+
420	101	61	IDENT	t11
421	101	65	PLUS	+
422	101	67	IDENT	t12
423	101	70	RIGHT_PAR	)
424	101	71	SEMICOLON	;
425	102	1	RIGHT_BRACE	}
426	104	1	VOID_SYMBOL	void
427	104	6	IDENT	warning
428	104	13	LEFT_BRACE	{
429	106	1	RIGHT_BRACE	}
430	108	1	VOID_SYMBOL	void
431	108	6	IDENT	test
432	108	10	LEFT_BRACE	{
433	109	5	INT_SYMBOL	int
434	109	9	IDENT	int_test
435	109	17	SEMICOLON	;
436	110	5	CHAR_SYMBOL	char
437	110	10	IDENT	char_test
438	110	19	SEMICOLON	;
439	111	5	INT_SYMBOL	int
440	111	9	IDENT	_abcdefghijklmnopqrstuvwxyz0123456789
441	111	46	SEMICOLON	;
442	112	5	CHAR_SYMBOL	char
443	112	10	IDENT	letters
444	112	17	LEFT_BRACKET	[
445	112	18	INT	3
446	112	21	RIGHT_BRACKET	]
447	112	22	SEMICOLON	;
448	113	5	INT_SYMBOL	int
449	113	9	IDENT	i
450	113	10	SEMICOLON	;
451	115	5	IDENT	char_test
452	115	15	BECOME	=
453	115	17	CHAR	A
454	115	20	SEMICOLON	;
455	116	5	IDENT	letters
456	116	12	LEFT_BRACKET	[
457	116	13	INT	0
458	116	14	RIGHT_BRACKET	]
459	116	16	BECOME	=
460	116	18	CHAR	1
461	116	21	SEMICOLON	;
462	117	5	IDENT	letters
463	117	12	LEFT_BRACKET	[
464	117	13	INT	1
465	117	14	RIGHT_BRACKET	]
466	117	16	BECOME	=
467	117	18	CHAR	2
468	117	21	SEMICOLON	;
469	118	5	IDENT	letters
470	118	12	LEFT_BRACKET	[
471	118	13	INT	2
472	118	14	RIGHT_BRACKET	]
473	118	16	BECOME	=
474	118	18	CHAR	a
475	118	21	SEMICOLON	;
476	119	5	IDENT	i
477	119	7	BECOME	=
478	119	9	INT	10
479	119	11	SEMICOLON	;
480	121	5	IDENT	i
481	121	7	BECOME	=
482	121	9	IDENT	letters
483	121	16	LEFT_BRACKET	[
484	121	17	INT	0
485	121	18	RIGHT_BRACKET	]
486	121	20	PLUS	+
487	121	22	IDENT	letters
488	121	29	LEFT_BRACKET	[
489	121	30	INT	1
490	121	31	RIGHT_BRACKET	]
491	121	33	PLUS	+
492	121	35	IDENT	letters
493	121	42	LEFT_BRACKET	[
494	121	43	INT	2
495	121	44	RIGHT_BRACKET	]
496	121	45	SEMICOLON	;
497	123	5	IDENT	i
498	123	7	BECOME	=
499	123	9	IDENT	int_test
500	123	18	PLUS	+
501	123	20	IDENT	int_test
502	123	29	PLUS	+
503	123	31	IDENT	int_test
504	123	40	SUB	-
505	123	42	IDENT	int_test
506	123	51	MULT	*
507	123	53	IDENT	int_test
508	123	61	SEMICOLON	;
509	125	5	SWITCH_SYMBOL	switch
510	125	11	LEFT_PAR	(
511	125	12	IDENT	char_test
512	125	21	RIGHT_PAR	)
513	125	22	LEFT_BRACE	{
514	126	6	CASE_SYMBOL	case
515	126	11	CHAR	A
516	126	14	COLON	:
517	127	6	DO_SYMBOL	do
518	127	8	LEFT_BRACE	{
519	128	7	IDENT	int_test
520	128	16	BECOME	=
521	128	18	INT	133
522	128	22	SUB	-
523	128	24	INT	1
524	128	26	MULT	*
525	128	28	INT	2
526	128	30	MULT	*
527	128	32	INT	3
528	128	34	DIV	/
529	128	36	LEFT_PAR	(
530	128	37	INT	4
531	128	39	SUB	-
532	128	41	INT	1
533	128	42	RIGHT_PAR	)
534	128	44	PLUS	+
535	128	46	IDENT	char_test
536	128	56	PLUS	+
537	128	58	IDENT	letters
538	128	65	LEFT_BRACKET	[
539	128	66	INT	1
540	128	67	RIGHT_BRACKET	]
541	128	69	SUB	-
542	128	71	IDENT	letters
543	128	78	LEFT_BRACKET	[
544	128	79	INT	0
545	128	80	RIGHT_BRACKET	]
546	128	82	SUB	-
547	128	84	IDENT	letters
548	128	91	LEFT_BRACKET	[
549	128	92	INT	2
550	128	93	RIGHT_BRACKET	]
551	128	95	PLUS	+
552	128	97	IDENT	i
553	128	99	MULT	*
554	128	101	LEFT_PAR	(
555	128	102	INT	1
556	128	103	RIGHT_PAR	)
557	128	105	PLUS	+
558	128	107	INT	2
559	128	109	DIV	/
560	128	111	INT	3
561	128	112	SEMICOLON	;
562	129	7	IDENT	i
563	129	9	BECOME	=
564	129	11	IDENT	i
565	129	13	SUB	-
566	129	15	INT	1
567	129	16	SEMICOLON	;
568	130	6	RIGHT_BRACE	}
569	130	7	WHILE_SYMBOL	while
570	130	12	LEFT_PAR	(
571	130	13	IDENT	i
572	130	15	GTREQL	>=
573	130	18	INT	0
574	130	19	RIGHT_PAR	)
575	132	6	CASE_SYMBOL	case
576	132	11	CHAR	a
577	132	14	COLON	:
578	133	6	IDENT	int_test
579	133	15	BECOME	=
580	133	17	INT	223
581	133	21	SUB	-
582	133	23	INT	1
583	133	25	MULT	*
584	133	27	INT	2
585	133	29	MULT	*
586	133	31	INT	3
587	133	33	DIV	/
588	133	35	LEFT_PAR	(
589	133	36	INT	4
590	133	38	SUB	-
591	133	40	INT	1
592	133	41	RIGHT_PAR	)
593	133	43	PLUS	+
594	133	45	IDENT	char_test
595	133	55	PLUS	+
596	133	57	IDENT	letters
597	133	64	LEFT_BRACKET	[
598	133	65	INT	1
599	133	66	RIGHT_BRACKET	]
600	133	68	SUB	-
601	133	70	IDENT	letters
602	133	77	LEFT_BRACKET	[
603	133	78	INT	0
604	133	79	RIGHT_BRACKET	]
605	133	81	SUB	-
606	133	83	IDENT	letters
607	133	90	LEFT_BRACKET	[
608	133	91	INT	2
609	133	92	RIGHT_BRACKET	]
610	133	94	PLUS	+
611	133	96	IDENT	i
612	133	98	MULT	*
613	133	100	LEFT_PAR	(
614	133	101	INT	1
615	133	102	RIGHT_PAR	)
616	133	103	SEMICOLON	;
617	135	6	DEFAULT_SYMBOL	default
618	135	13	COLON	:
619	136	6	IDENT	int_test
620	136	15	BECOME	=
621	136	17	SUB	-
622	136	18	INT	1
623	136	19	SEMICOLON	;
624	137	5	RIGHT_BRACE	}
625	139	5	PRINTF_SYMBOL	printf
626	139	11	LEFT_PAR	(
627	139	12	STRING	
628	139	14	RIGHT_PAR	)
629	139	15	SEMICOLON	;
630	140	5	PRINTF_SYMBOL	printf
631	140	11	LEFT_PAR	(
632	140	12	STRING	Complex Expression = 
633	140	35	COMMA	,
634	140	37	IDENT	int_test
635	140	45	RIGHT_PAR	)
636	140	46	SEMICOLON	;
637	142	5	IDENT	i
638	142	7	BECOME	=
639	142	9	INT	10
640	142	11	SEMICOLON	;
641	143	5	DO_SYMBOL	do
642	143	7	LEFT_BRACE	{
643	144	6	IF_SYMBOL	if
644	144	8	LEFT_PAR	(
645	144	9	IDENT	i
646	144	11	GTREQL	>=
647	144	14	INT	5
648	144	15	RIGHT_PAR	)
649	145	7	SWITCH_SYMBOL	switch
650	145	13	LEFT_PAR	(
651	145	14	IDENT	i
652	145	15	RIGHT_PAR	)
653	145	16	LEFT_BRACE	{
654	146	8	CASE_SYMBOL	case
655	146	13	INT	10
656	146	15	COLON	:
657	147	8	IDENT	char_test
658	147	18	BECOME	=
659	147	20	CHAR	A
660	147	23	SEMICOLON	;
661	148	8	CASE_SYMBOL	case
662	148	13	CHAR	9
663	148	16	COLON	:
664	149	8	IDENT	char_test
665	149	18	BECOME	=
666	149	20	CHAR	B
667	149	23	SEMICOLON	;
668	150	8	CASE_SYMBOL	case
669	150	13	INT	8
670	150	14	COLON	:
671	151	8	IDENT	char_test
672	151	18	BECOME	=
673	151	20	CHAR	C
674	151	23	SEMICOLON	;
675	152	8	CASE_SYMBOL	case
676	152	13	CHAR	7
677	152	16	COLON	:
678	153	8	IDENT	char_test
679	153	18	BECOME	=
680	153	20	CHAR	D
681	153	23	SEMICOLON	;
682	154	8	CASE_SYMBOL	case
683	154	13	INT	6
684	154	14	COLON	:
685	155	8	IDENT	char_test
686	155	18	BECOME	=
687	155	20	CHAR	E
688	155	23	SEMICOLON	;
689	156	8	DEFAULT_SYMBOL	default
690	156	15	COLON	:
691	157	8	IDENT	char_test
692	157	18	BECOME	=
693	157	20	CHAR	F
694	157	23	SEMICOLON	;
695	158	7	RIGHT_BRACE	}
696	159	6	ELSE_SYMBOL	else
697	160	7	SWITCH_SYMBOL	switch
698	160	13	LEFT_PAR	(
699	160	14	INT	2
700	160	16	MULT	*
701	160	18	IDENT	i
702	160	20	DIV	/
703	160	22	INT	2
704	160	24	PLUS	+
705	160	26	CHAR	0
706	160	30	SUB	-
707	160	32	INT	0
708	160	33	RIGHT_PAR	)
709	160	34	LEFT_BRACE	{
710	161	8	CASE_SYMBOL	case
711	161	13	INT	0
712	161	14	COLON	:
713	162	8	IDENT	char_test
714	162	18	BECOME	=
715	162	20	CHAR	A
716	162	23	SEMICOLON	;
717	163	8	CASE_SYMBOL	case
718	163	13	CHAR	0
719	163	16	COLON	:
720	164	8	IDENT	char_test
721	164	18	BECOME	=
722	164	20	CHAR	0
723	164	23	SEMICOLON	;
724	165	8	DEFAULT_SYMBOL	default
725	165	15	COLON	:
726	166	8	IDENT	char_test
727	166	18	BECOME	=
728	166	20	CHAR	G
729	166	23	SEMICOLON	;
730	167	7	RIGHT_BRACE	}
731	168	6	IDENT	i
732	168	8	BECOME	=
733	168	10	IDENT	i
734	168	12	SUB	-
735	168	14	INT	1
736	168	15	SEMICOLON	;
737	169	5	RIGHT_BRACE	}
738	169	6	WHILE_SYMBOL	while
739	169	11	LEFT_PAR	(
740	169	12	IDENT	i
741	169	14	GTREQL	>=
742	169	17	INT	0
743	169	18	RIGHT_PAR	)
744	171	5	IDENT	output
745	171	11	LEFT_PAR	(
746	171	12	IDENT	char_test
747	171	21	RIGHT_PAR	)
748	171	22	SEMICOLON	;
749	173	5	SEMICOLON	;
750	174	5	LEFT_BRACE	{
751	174	6	LEFT_BRACE	{
752	174	7	RIGHT_BRACE	}
753	174	8	LEFT_BRACE	{
754	174	9	RIGHT_BRACE	}
755	174	10	LEFT_BRACE	{
756	174	11	SEMICOLON	;
757	174	12	RIGHT_BRACE	}
758	174	13	RIGHT_BRACE	}
759	175	5	LEFT_BRACE	{
760	175	6	RIGHT_BRACE	}
761	176	5	LEFT_BRACE	{
762	176	6	SEMICOLON	;
763	176	7	LEFT_BRACE	{
764	176	8	SEMICOLON	;
765	176	9	RIGHT_BRACE	}
766	176	10	SEMICOLON	;
767	176	11	RIGHT_BRACE	}
768	178	5	IDENT	error
769	178	10	LEFT_PAR	(
770	178	11	INT	4
771	178	12	RIGHT_PAR	)
772	178	13	SEMICOLON	;
773	179	1	RIGHT_BRACE	}
774	181	1	VOID_SYMBOL	void
775	181	6	MAIN_SYMBOL	main
776	181	10	LEFT_PAR	(
777	181	11	RIGHT_PAR	)
778	182	1	LEFT_BRACE	{
779	183	5	INT_SYMBOL	int
780	183	9	IDENT	x
781	183	10	COMMA	,
782	183	11	IDENT	y
783	183	12	SEMICOLON	;
784	184	5	CHAR_SYMBOL	char
785	184	10	IDENT	input
786	184	15	SEMICOLON	;
787	185	5	CHAR_SYMBOL	char
788	185	10	IDENT	c
789	185	11	SEMICOLON	;
790	186	5	INT_SYMBOL	int
791	186	9	IDENT	result
792	186	15	LEFT_BRACKET	[
793	186	16	INT	200
794	186	19	RIGHT_BRACKET	]
795	186	20	SEMICOLON	;
796	188	5	IDENT	t1
797	188	8	BECOME	=
798	188	10	INT	1
799	188	11	SEMICOLON	;
800	189	5	IDENT	t2
801	189	8	BECOME	=
802	189	10	INT	2
803	189	11	SEMICOLON	;
804	190	5	IDENT	label
805	190	11	BECOME	=
806	190	13	CHAR	0
807	190	16	SEMICOLON	;
808	191	5	IDENT	label1
809	191	12	BECOME	=
810	191	14	CHAR	1
811	191	17	SEMICOLON	;
812	192	5	IDENT	label2
813	192	12	BECOME	=
814	192	14	CHAR	2
815	192	17	SEMICOLON	;
816	195	5	PRINTF_SYMBOL	printf
817	195	11	LEFT_PAR	(
818	195	12	STRING	Please Input Lower Bound and Upper Bound:
819	195	55	RIGHT_PAR	)
820	195	56	SEMICOLON	;
821	196	5	SCANF_SYMBOL	scanf
822	196	10	LEFT_PAR	(
823	196	11	IDENT	x
824	196	12	COMMA	,
825	196	13	IDENT	y
826	196	14	RIGHT_PAR	)
827	196	15	SEMICOLON	;
828	198	5	PRINTF_SYMBOL	printf
829	198	11	LEFT_PAR	(
830	198	12	STRING	Please Input A Char:
831	198	34	RIGHT_PAR	)
832	198	35	SEMICOLON	;
833	199	5	SCANF_SYMBOL	scanf
834	199	10	LEFT_PAR	(
835	199	11	IDENT	input
836	199	16	RIGHT_PAR	)
837	199	17	SEMICOLON	;
838	201	5	IDENT	i
839	201	7	BECOME	=
840	201	9	INT	0
841	201	10	SEMICOLON	;
842	203	5	DO_SYMBOL	do
843	204	9	IDENT	result
844	204	15	LEFT_BRACKET	[
845	204	16	IDENT	i
846	204	18	MULT	*
847	204	20	INT	1
848	204	22	SUB	-
849	204	24	INT	1
850	204	26	PLUS	+
851	204	28	INT	1
852	204	30	DIV	/
853	204	32	INT	1
854	204	33	RIGHT_BRACKET	]
855	204	35	BECOME	=
856	204	37	IDENT	cumulative_sum
857	204	51	LEFT_PAR	(
858	204	52	IDENT	x
859	204	53	COMMA	,
860	204	54	IDENT	y
861	204	55	RIGHT_PAR	)
862	204	56	SEMICOLON	;
863	205	5	WHILE_SYMBOL	while
864	205	10	LEFT_PAR	(
865	205	11	INT	0
866	205	12	RIGHT_PAR	)
867	207	5	IDENT	i
868	207	7	BECOME	=
869	207	9	INT	1
870	207	10	SEMICOLON	;
871	208	5	DO_SYMBOL	do
872	208	7	LEFT_BRACE	{
873	209	9	IDENT	result
874	209	15	LEFT_BRACKET	[
875	209	16	IDENT	i
876	209	17	RIGHT_BRACKET	]
877	209	19	BECOME	=
878	209	21	IDENT	i
879	209	22	SEMICOLON	;
880	210	9	IDENT	i
881	210	11	BECOME	=
882	210	13	IDENT	i
883	210	15	PLUS	+
884	210	17	INT	1
885	210	18	SEMICOLON	;
886	211	5	RIGHT_BRACE	}
887	211	6	WHILE_SYMBOL	while
888	211	11	LEFT_PAR	(
889	211	12	IDENT	i
890	211	14	LSS	<
891	211	16	IDENT	y
892	211	18	SUB	-
893	211	20	IDENT	x
894	211	21	RIGHT_PAR	)
895	213	5	IDENT	i
896	213	7	BECOME	=
897	213	9	INT	1
898	213	10	SEMICOLON	;
899	215	5	IF_SYMBOL	if
900	215	7	LEFT_PAR	(
901	215	8	IDENT	x
902	215	10	GTREQL	>=
903	215	13	SUB	-
904	215	14	INT	100
905	215	17	RIGHT_PAR	)
906	215	18	LEFT_BRACE	{
907	216	9	IF_SYMBOL	if
908	216	11	LEFT_PAR	(
909	216	12	IDENT	y
910	216	14	LSSEQL	<=
911	216	17	INT	100
912	216	20	RIGHT_PAR	)
913	216	21	LEFT_BRACE	{
914	217	13	IF_SYMBOL	if
915	217	15	LEFT_PAR	(
916	217	16	IDENT	x
917	217	18	LSSEQL	<=
918	217	21	IDENT	y
919	217	22	RIGHT_PAR	)
920	217	23	LEFT_BRACE	{
921	218	17	PRINTF_SYMBOL	printf
922	218	23	LEFT_PAR	(
923	218	24	STRING	X sum to Y = 
924	218	39	COMMA	,
925	218	41	IDENT	result
926	218	47	LEFT_BRACKET	[
927	218	48	INT	0
928	218	49	RIGHT_BRACKET	]
929	218	50	RIGHT_PAR	)
930	218	51	SEMICOLON	;
931	219	13	RIGHT_BRACE	}
932	220	13	ELSE_SYMBOL	else
933	221	14	SEMICOLON	;
934	222	9	RIGHT_BRACE	}
935	223	9	ELSE_SYMBOL	else
936	224	10	SEMICOLON	;
937	225	5	RIGHT_BRACE	}
938	226	5	ELSE_SYMBOL	else
939	227	6	SEMICOLON	;
940	229	5	PRINTF_SYMBOL	printf
941	229	11	LEFT_PAR	(
942	229	12	STRING	It's already 
943	229	27	COMMA	,
944	229	29	IDENT	returnyear
945	229	39	RIGHT_PAR	)
946	229	40	SEMICOLON	;
947	231	5	IDENT	c
948	231	7	BECOME	=
949	231	9	IDENT	output
950	231	15	LEFT_PAR	(
951	231	16	IDENT	input
952	231	21	RIGHT_PAR	)
953	231	22	SEMICOLON	;
954	232	5	IF_SYMBOL	if
955	232	7	LEFT_PAR	(
956	232	8	LEFT_PAR	(
957	232	9	IDENT	c
958	232	10	RIGHT_PAR	)
959	232	12	EQLEQL	==
960	232	15	LEFT_PAR	(
961	232	16	CHAR	c
962	232	19	RIGHT_PAR	)
963	232	20	RIGHT_PAR	)
964	233	9	PRINTF_SYMBOL	printf
965	233	15	LEFT_PAR	(
966	233	16	STRING	It is Lower c.
967	233	32	COMMA	,
968	233	34	IDENT	t1
969	233	36	RIGHT_PAR	)
970	233	37	SEMICOLON	;
971	234	5	ELSE_SYMBOL	else
972	235	9	PRINTF_SYMBOL	printf
973	235	15	LEFT_PAR	(
974	235	16	STRING	It is not Lower c
975	235	35	COMMA	,
976	235	37	IDENT	t2
977	235	39	RIGHT_PAR	)
978	235	40	SEMICOLON	;
979	237	5	IDENT	c
980	237	7	BECOME	=
981	237	9	IDENT	returnc
982	237	16	SEMICOLON	;
983	238	5	IF_SYMBOL	if
984	238	7	LEFT_PAR	(
985	238	8	IDENT	c
986	238	10	PLUS	+
987	238	12	INT	0
988	238	14	EQLEQL	==
989	238	17	CHAR	C
990	238	21	PLUS	+
991	238	23	INT	0
992	238	24	RIGHT_PAR	)
993	239	9	PRINTF_SYMBOL	printf
994	239	15	LEFT_PAR	(
995	239	16	STRING	\tReturnC is Upper C.\n
996	239	41	RIGHT_PAR	)
997	239	42	SEMICOLON	;
998	240	5	ELSE_SYMBOL	else
999	241	9	PRINTF_SYMBOL	printf
1000	241	15	LEFT_PAR	(
1001	241	16	STRING	ReturnC is not Upper C
1002	241	40	RIGHT_PAR	)
1003	241	41	SEMICOLON	;
1004	243	5	IDENT	warning
1005	243	12	SEMICOLON	;
1006	244	5	IDENT	test
1007	244	9	SEMICOLON	;
1008	245	5	PRINTF_SYMBOL	printf
1009	245	11	LEFT_PAR	(
1010	245	12	STRING	Final i = 
1011	245	24	COMMA	,
1012	245	26	IDENT	i
1013	245	27	RIGHT_PAR	)
1014	245	28	SEMICOLON	;
1015	246	5	PRINTF_SYMBOL	printf
1016	246	11	LEFT_PAR	(
1017	246	12	STRING	Register_Disater = 
1018	246	33	COMMA	,
1019	246	35	IDENT	register_disaster
1020	246	52	LEFT_PAR	(
1021	246	53	INT	0
1022	246	54	COMMA	,
1023	246	55	INT	0
1024	246	56	COMMA	,
1025	246	57	INT	0
1026	246	58	COMMA	,
1027	246	59	INT	0
1028	246	60	COMMA	,
1029	246	61	INT	0
1030	246	62	COMMA	,
1031	246	63	INT	0
1032	246	64	COMMA	,
1033	246	65	INT	0
1034	246	66	COMMA	,
1035	246	67	INT	0
1036	246	68	COMMA	,
1037	246	69	INT	0
1038	246	70	COMMA	,
1039	246	71	INT	0
1040	246	72	COMMA	,
1041	246	73	INT	0
1042	246	74	COMMA	,
1043	246	75	INT	0
1044	246	76	RIGHT_PAR	)
1045	246	77	RIGHT_PAR	)
1046	246	78	SEMICOLON	;
1047	247	1	RIGHT_BRACE	}
